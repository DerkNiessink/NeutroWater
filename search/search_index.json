{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NeutroWater NeutroWater is a Monte Carlo simulation designed to explore neutron moderation within a water-filled tank, focusing on analyzing neutron flux and energy distribution. The project started under the University of Amsterdam's physics lab, which has a neutron source generating \\(9.3 \\cdot 10^5\\) neutrons per second with energies of \\(3-10\\) MeV. It's a blend of americium-241 (11 GBq activity) and beryllium-9. These neutrons can be used to activate other materials: by capturing a neutron, the mass number of the atomic nuclei increases, creating other isotopes. The reason for this project is that we lacked data on neutron energy distribution and density in the tank, crucial for safety and activation efficiency. Contents User Guide Theory and Methodology Results API reference Citings","title":"NeutroWater"},{"location":"#neutrowater","text":"NeutroWater is a Monte Carlo simulation designed to explore neutron moderation within a water-filled tank, focusing on analyzing neutron flux and energy distribution. The project started under the University of Amsterdam's physics lab, which has a neutron source generating \\(9.3 \\cdot 10^5\\) neutrons per second with energies of \\(3-10\\) MeV. It's a blend of americium-241 (11 GBq activity) and beryllium-9. These neutrons can be used to activate other materials: by capturing a neutron, the mass number of the atomic nuclei increases, creating other isotopes. The reason for this project is that we lacked data on neutron energy distribution and density in the tank, crucial for safety and activation efficiency.","title":"NeutroWater"},{"location":"#contents","text":"User Guide Theory and Methodology Results API reference Citings","title":"Contents"},{"location":"citings/","text":"Citings Methods Paul K. Romano, Nicholas E. Horelik, Bryan R. Herman, Adam G. Nelson, Benoit Forget, and Kord Smith, \u201cOpenMC: A State-of-the-Art Monte Carlo Code for Research and Development,\u201d Ann. Nucl. Energy, 82, 90\u201397 (2015). Data","title":"Citings"},{"location":"citings/#citings","text":"","title":"Citings"},{"location":"citings/#methods","text":"Paul K. Romano, Nicholas E. Horelik, Bryan R. Herman, Adam G. Nelson, Benoit Forget, and Kord Smith, \u201cOpenMC: A State-of-the-Art Monte Carlo Code for Research and Development,\u201d Ann. Nucl. Energy, 82, 90\u201397 (2015).","title":"Methods"},{"location":"citings/#data","text":"","title":"Data"},{"location":"reference/","text":"NeutroWater API The easiest way to get started with NeutroWater is to look at the Example . NeutroWater includes a Python API that enables running the simulation and analyzing the results. The two public modules are listed and documented below: neutrowater.diffusing_neutrons - Simulation Set-up and Running neutrowater.post - Post Simulation Analysis Simulation Set-up and Running neutrowater.diffusing_neutrons This module provides a class to simulate the diffusion of neutrons in a medium. Classes: Name Description Parameters Class to store the parameters for the simulation. DiffusingNeutrons Class to simulate the diffusion of neutrons in a medium. DiffusingNeutrons Class that simulates multiple neutrons from diffusing in a medium. Parameters: p ( Parameters ) \u2013 Parameters for the simulation. Source code in neutrowater/diffusing_neutrons.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class DiffusingNeutrons : \"\"\" Class that simulates multiple neutrons from diffusing in a medium. Args: p (Parameters): Parameters for the simulation. \"\"\" def __init__ ( self , p : Parameters , ): self . kT = ( 1.380649e-23 * p . temperature * 6.24150907 * 10 ** 18 ) # [m^2 kg / (s^2 K) * K * (eV/J) = J*(eV/J) = eV] self . nCollisions = 0 self . mol_struc = p . molecule_structure self . tank = Tank ( p . radius_tank , p . height_tank , p . position_tank ) # For interpolating the total cross section data and computing the # mean-free-path. self . total_processor = TotalProcessor ( p . total_data ) # For interpolating the scattering and absorption cross section and # computing the aborption ratio. self . absorption_processor = AbsorptionProcessor ( p . scattering_data , p . absorption_data ) # Sample from the interpolated energy spectrum spectrum_processor = SpectrumProcessor ( p . spectrum_data ) initial_energies = spectrum_processor . sample ( num_samples = p . nNeutrons ) # Convert the energies MeV -> eV initial_energies = [ energy * 10 ** 6 for energy in initial_energies ] # All neutrons start at the origin initial_positions = [ np . array ([ 0 , 0 , 0 ]) for _ in range ( p . nNeutrons )] self . neutrons = Neutrons ( initial_energies , initial_positions ) # For handling the collisions with the atomic nuclei, hydrogen and oxygen. self . nuclei_masses = p . nuclei_masses # Maxwell-Boltzmann distribution for the thermal energy self . mw = MaxwellBoltzmann ( T = p . temperature ) # For handling the angular distribution of the scattering. self . angular_processor = AngularProcessor ( p . angular_data , p . nuclei_masses ) def diffuse ( self , nCollisions : int ): \"\"\" Let the neutrons diffuse in the medium. Args: nCollisions (int): number of times each neutron collides with an atomic nucleus. \"\"\" self . nCollisions += nCollisions # Using not all cores but 2 less than the total number of cores, tends # to be faster num_processes = multiprocessing . cpu_count () - 2 # Split the neutrons into chunks chunk_size = ( len ( self . neutrons ) + num_processes - 1 ) // num_processes chunks = [ self . neutrons [ i : i + chunk_size ] for i in range ( 0 , len ( self . neutrons ), chunk_size ) ] # Diffuse the chuncks of neutrons in parallel with multiprocessing . Pool ( processes = num_processes ) as pool : results = list ( process_map ( self . _diffuse_chunk , chunks , [ nCollisions ] * len ( chunks )), ) # Update the neutrons list with the results from the parallel processess self . neutrons = [ neutron for chunk in results for neutron in chunk ] def _diffuse_chunk ( self , chunk : Neutrons , nCollisions : int ): \"\"\" Diffuse a chunk of all neutrons in the medium. Args: chunk (Sequence[Neutron]): chunk of neutrons to diffuse nCollisions (int): number of times each neutron collides with an atomic nucleus. Returns: the neutrons after diffusing in the medium. \"\"\" np . random . seed () # Set a new seed for each process return [ self . _diffuse_neutron ( neutron , nCollisions ) for neutron in chunk ] def _diffuse_neutron ( self , neutron : Neutron , nCollisions : int ) -> Neutron : \"\"\" Diffuse a single neutron in the medium. Args: neutron (Neutron): Neutron to diffuse nCollisions (int): number of times the neutron collides with an atomic nucleus. Returns: the neutron after diffusing in the medium. \"\"\" neutron . direction = random_direction () for _ in range ( nCollisions ): if not self . tank . inside ( neutron . position ): break # Sample the distance the neutron travels from an exponential distribution # with mean free path as the scale parameter. l = - self . total_processor . get_mfp ( neutron . energy ) * np . log ( random ()) neutron . travel ( l ) # Determine the nucleus the neutron collides with mass = ( self . nuclei_masses [ 0 ] if random () < self . total_processor . get_ratio ( neutron . energy ) else self . nuclei_masses [ 1 ] ) collision = Collision ( initial_E = neutron . energy , initial_direction = neutron . direction , mass = mass , scattering_cosine = self . angular_processor . get_CM_cosines ( mass , neutron . energy , 1 )[ 0 ], absorption = self . _absorbed ( neutron , self . nuclei_masses . index ( mass )), thermal = neutron . energy < 10 * self . kT , ) # Update the neutron's energy and direction neutron . collide ( collision . energy_loss_frac , collision . scattering_direction ) # If the neutron is absorbed, break the loop if collision . energy_loss_frac == 1 : break return neutron def _absorbed ( self , neutron : Neutron , index : int ) -> bool : \"\"\" Check if the neutron is absorbed by the nucleus. Args: neutron (Neutron): Neutron to check. index (int): index of the nucleus in the molecule. Returns: True if the neutron is absorbed, False otherwise. \"\"\" if ( random () < self . absorption_processor . get_absorption_rates ( neutron . energy )[ index ] ): return True else : return False diffuse ( nCollisions ) Let the neutrons diffuse in the medium. Parameters: nCollisions ( int ) \u2013 number of times each neutron collides with an atomic nucleus. Source code in neutrowater/diffusing_neutrons.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def diffuse ( self , nCollisions : int ): \"\"\" Let the neutrons diffuse in the medium. Args: nCollisions (int): number of times each neutron collides with an atomic nucleus. \"\"\" self . nCollisions += nCollisions # Using not all cores but 2 less than the total number of cores, tends # to be faster num_processes = multiprocessing . cpu_count () - 2 # Split the neutrons into chunks chunk_size = ( len ( self . neutrons ) + num_processes - 1 ) // num_processes chunks = [ self . neutrons [ i : i + chunk_size ] for i in range ( 0 , len ( self . neutrons ), chunk_size ) ] # Diffuse the chuncks of neutrons in parallel with multiprocessing . Pool ( processes = num_processes ) as pool : results = list ( process_map ( self . _diffuse_chunk , chunks , [ nCollisions ] * len ( chunks )), ) # Update the neutrons list with the results from the parallel processess self . neutrons = [ neutron for chunk in results for neutron in chunk ] Parameters dataclass Class to store the parameters for the simulation. Parameters: nNeutrons ( int ) \u2013 Number of neutrons to simulate molecule_structure ( Sequence , default: (2, 1) ) \u2013 number of atoms in the molecule. nuclei_masses ( Sequence , default: (1, 16) ) \u2013 Masses of the nuclei in the molecule, should be in the same order as the molecule_structure. radius_tank ( float , default: 1 ) \u2013 Radius of the tank in meters. height_tank ( float , default: 1 ) \u2013 Height of the tank in meters. position_tank ( ndarray , default: (0.0, 0.0, 0.0) ) \u2013 Position of the tank. temperature ( float , default: 293 ) \u2013 Temperature [K] of the medium. Source code in neutrowater/diffusing_neutrons.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @dataclass class Parameters : \"\"\" Class to store the parameters for the simulation. Args: nNeutrons (int): Number of neutrons to simulate molecule_structure (Sequence): number of atoms in the molecule. nuclei_masses (Sequence): Masses of the nuclei in the molecule, should be in the same order as the molecule_structure. radius_tank (float): Radius of the tank in meters. height_tank (float): Height of the tank in meters. position_tank (np.ndarray): Position of the tank. temperature (float): Temperature [K] of the medium. \"\"\" nNeutrons : int molecule_structure : Sequence = ( 2 , 1 ) nuclei_masses : Sequence = ( 1 , 16 ) radius_tank : float = 1 height_tank : float = 1 position_tank : tuple = ( 0.0 , 0.0 , 0.0 ) temperature : float = 293 def __post_init__ ( self ): files = resources . files ( data ) self . total_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"h_cross_t.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"o_cross_t.txt\" , sep = r \"\\s+\" ), ] self . scattering_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"h_cross_s.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"o_cross_s.txt\" , sep = r \"\\s+\" ), ] self . absorption_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"h_cross_a.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"o_cross_a.txt\" , sep = r \"\\s+\" ), ] self . angular_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"H_angular.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"O_angular.txt\" , sep = r \",\" ), ] self . spectrum_data : pd . DataFrame = pd . read_csv ( files / \"neutron_spectrum_normalized.txt\" , sep = \",\" ) Post Simulation Analysis neutrowater.post.plot This module provides a function to plot the trajectories of the neutrons. Functions: Name Description trajectories Show the trajectories of the neutrons. trajectories ( diffusing_neutrons ) Show the trajectories of the neutrons. Parameters: diffusing_neutrons ( DiffusingNeutrons ) \u2013 Object of the class DiffusingNeutrons. Source code in neutrowater/post/plot.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def trajectories ( diffusing_neutrons : DiffusingNeutrons ): \"\"\" Show the trajectories of the neutrons. Args: diffusing_neutrons (DiffusingNeutrons): Object of the class DiffusingNeutrons. \"\"\" df = diffusing_neutrons measurer = measure . Measurer ( df ) radius = df . tank . radius height = df . tank . height tank_position = df . tank . position fig = plt . figure ( figsize = ( 8 , 8 )) ax = fig . add_subplot ( 111 , projection = \"3d\" ) for position in measurer . positions (): x = [ p [ 0 ] for p in position ] y = [ p [ 1 ] for p in position ] z = [ p [ 2 ] for p in position ] ax . plot ( x , y , z , c = \"k\" , linewidth = 0.5 , alpha = 0.7 ) ax . plot ( 0 , 0 , 0 , \"o\" , c = \"r\" ) ax . set_xlabel ( \"$x(m)$\" , fontsize = 16 ) ax . set_ylabel ( \"$y(m)$\" , fontsize = 16 ) ax . set_box_aspect ( aspect = None , zoom = 2 ) ax . set_zlabel ( \"$z(m)$\" , fontsize = 16 ) ax . set_title ( \"Neutron trajectories\" ) ax . set_xlim ( - 0.4 , 0.4 ) ax . set_ylim ( - 0.4 , 0.4 ) ax . axis ( \"off\" ) ax . margins ( x = 0 , y = 0 ) ax . spines [[ \"right\" , \"top\" ]] . set_visible ( False ) if df . tank is not None : u = np . linspace ( 0 , 2 * np . pi , 100 ) v = np . linspace ( 0 , height , 100 ) x = radius * np . outer ( np . cos ( u ), np . ones_like ( v )) + tank_position [ 0 ] y = radius * np . outer ( np . sin ( u ), np . ones_like ( v )) + tank_position [ 1 ] z = ( np . outer ( np . ones_like ( u ), v ) - height / 2 + tank_position [ 2 ] ) # Adjust the height of the cylinder ax . plot_surface ( x , y , z , color = \"cornflowerblue\" , alpha = 0.3 ) plt . show () neutrowater.post.measure This module provides a class to measure the properties of the neutrons. Classes: Name Description Measurer Class to measure the properties of the neutrons after the simulation. Measurer Class to measure the properties of the neutrons after the simulation. Methods: Name Description positions Get the positions of the neutrons. energies Get the energies of the neutrons. number_total Get the total number of neutrons. number_escaped Get the number of neutrons that escaped the tank. number_thermal Get the number of neutrons that are thermalized. thermalize_positions Get the positions of the neutrons where their energy is thermal for the first time. thermalize_distances Get the distance of the neutrons where their energy is thermal for the first time. number_absorbed Get the number of neutrons that were absorbed. absorbed_positions Get the positions of the neutrons that were absorbed. absorbed_distances Get the distances of the neutrons that were absorbed. flux Get the flux of the neutrons at a given radius r. energy_spectrum Get the energy spectrum of the neutrons at a given radius r. energy_spectrum_escaped Get the energy spectrum of the neutrons that escaped the tank. number_above_energy Get the number of neutrons with energy above a given energy. Source code in neutrowater/post/measure.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class Measurer : \"\"\"Class to measure the properties of the neutrons after the simulation. Methods: positions: Get the positions of the neutrons. energies: Get the energies of the neutrons. number_total: Get the total number of neutrons. number_escaped: Get the number of neutrons that escaped the tank. number_thermal: Get the number of neutrons that are thermalized. thermalize_positions: Get the positions of the neutrons where their energy is thermal for the first time. thermalize_distances: Get the distance of the neutrons where their energy is thermal for the first time. number_absorbed: Get the number of neutrons that were absorbed. absorbed_positions: Get the positions of the neutrons that were absorbed. absorbed_distances: Get the distances of the neutrons that were absorbed. flux: Get the flux of the neutrons at a given radius r. energy_spectrum: Get the energy spectrum of the neutrons at a given radius r. energy_spectrum_escaped: Get the energy spectrum of the neutrons that escaped the tank. number_above_energy: Get the number of neutrons with energy above a given energy. \"\"\" def __init__ ( self , sim : DiffusingNeutrons ): self . neutrons = sim . neutrons self . sim = sim def positions ( self ) -> list [ list [ Vector ]]: \"\"\" Get the positions of the neutrons. Returns: a list where each element is a list of length nNeutrons [[np.ndarray, np.ndarray, ...], [np.ndarray, np.ndarray, ...], ...] \"\"\" return [ neutron . positions for neutron in self . neutrons ] def energies ( self ) -> list [ list [ float ]]: \"\"\" Get the energies of the neutrons. Returns: a list where each element is a list of length nNeutrons [[float, float, ...], [float, float, ...], ...] \"\"\" return [ neutron . energies for neutron in self . neutrons ] def number_total ( self ) -> int : \"\"\" Get the total number of neutrons. Returns: an int. \"\"\" return len ( self . neutrons ) def number_escaped ( self ) -> int : \"\"\" Get the number of neutrons that escaped the tank. Returns: an int. \"\"\" return sum ( [ 1 for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ], start = 0 , ) def number_thermal ( self ) -> int : \"\"\" Get the number of neutrons that are thermalized. Returns: an int. \"\"\" n = 0 for energies in self . energies (): if energies [ - 1 ] < ( 10 * self . sim . kT ): n += 1 return n def thermalize_positions ( self ) -> list : \"\"\" Get the positions of the neutrons where their energy is thermal for the first time. Returns: a list of np.ndarray. \"\"\" thermalize_positions = [] for energies , positions in zip ( self . energies (), self . positions ()): # Get the first element of the list of energies that is less than 10kT res = list ( filter (( lambda val : val < ( 10 * self . sim . kT )), energies )) if len ( res ) > 0 : index = energies . index ( res [ 0 ]) thermalize_positions . append ( positions [ index ]) return thermalize_positions def thermalize_distances ( self ) -> list : \"\"\" Get the distance of the neutrons where their energy is thermal for the first time. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . thermalize_positions ()] def number_absorbed ( self ) -> int : \"\"\" Get the number of neutrons that were absorbed. Returns: an int. \"\"\" n = 0 for neutron in self . neutrons : if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ): n += 1 return n def absorbed_positions ( self ) -> list [ Vector ]: \"\"\" Get the positions of the neutrons that were absorbed. Returns: a list of np.ndarray. \"\"\" return [ neutron . positions [ - 1 ] for neutron in self . neutrons if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ) ] def absorbed_distances ( self ) -> list [ np . float64 ]: \"\"\" Get the distances of the neutrons that were absorbed. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . absorbed_positions ()] def flux ( self , r : float ) -> float : \"\"\" Get the flux of the neutrons at a given radius r. Args: r (float): radius at which to compute the flux. Returns: a float value of the flux. \"\"\" count = 0 for positions in self . positions (): positions = np . array ( positions ) norms = np . linalg . norm ( positions , axis = 1 ) # Count the number of neutrons that have been in the shell count += np . sum (( norms [: - 1 ] < r ) & ( r < norms [ 1 :])) + np . sum ( ( norms [ 1 :] < r ) & ( r < norms [: - 1 ]) ) return count / ( 4 * np . pi * r ** 2 ) def energy_spectrum ( self , r : float ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons at a given radius r. Args: r (float): radius at which to compute the energy spectrum. Returns: a list of floats. \"\"\" result_energies = [] for positions , energies in zip ( self . positions (), self . energies ()): positions = np . array ( positions ) energies = np . array ( energies ) norms = np . linalg . norm ( positions , axis = 1 ) # Create boolean arrays for the conditions cond1 = np . concatenate ([( norms [: - 1 ] < r ) & ( r < norms [ 1 :]), [ False ]]) cond2 = np . concatenate ([[ False ], ( norms [ 1 :] < r ) & ( r < norms [: - 1 ])]) # Get the energies of the neutrons that have been in the shell result_energies += list ( energies [ cond1 ]) + list ( energies [ cond2 ]) return result_energies def energy_spectrum_escaped ( self ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons that escaped the tank. Returns: a list of floats. \"\"\" return [ neutron . energy for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ] def number_above_energy ( self , E : float ) -> int : \"\"\" Get the number of neutrons with energy above a given energy. Args: E (float): energy threshold. Returns: an int. \"\"\" return sum ([ 1 for neutron in self . neutrons if neutron . energies [ 0 ] > E ]) absorbed_distances () Get the distances of the neutrons that were absorbed. Returns: list [ float64 ] \u2013 a list of floats. Source code in neutrowater/post/measure.py 155 156 157 158 159 160 161 162 def absorbed_distances ( self ) -> list [ np . float64 ]: \"\"\" Get the distances of the neutrons that were absorbed. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . absorbed_positions ()] absorbed_positions () Get the positions of the neutrons that were absorbed. Returns: list [ Vector ] \u2013 a list of np.ndarray. Source code in neutrowater/post/measure.py 141 142 143 144 145 146 147 148 149 150 151 152 153 def absorbed_positions ( self ) -> list [ Vector ]: \"\"\" Get the positions of the neutrons that were absorbed. Returns: a list of np.ndarray. \"\"\" return [ neutron . positions [ - 1 ] for neutron in self . neutrons if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ) ] energies () Get the energies of the neutrons. Returns: list [ list [ float ]] \u2013 a list where each element is a list of length nNeutrons [[float, float, ...], [float, float, ...], ...] Source code in neutrowater/post/measure.py 50 51 52 53 54 55 56 57 58 def energies ( self ) -> list [ list [ float ]]: \"\"\" Get the energies of the neutrons. Returns: a list where each element is a list of length nNeutrons [[float, float, ...], [float, float, ...], ...] \"\"\" return [ neutron . energies for neutron in self . neutrons ] energy_spectrum ( r ) Get the energy spectrum of the neutrons at a given radius r. Parameters: r ( float ) \u2013 radius at which to compute the energy spectrum. Returns: list [ float ] \u2013 a list of floats. Source code in neutrowater/post/measure.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def energy_spectrum ( self , r : float ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons at a given radius r. Args: r (float): radius at which to compute the energy spectrum. Returns: a list of floats. \"\"\" result_energies = [] for positions , energies in zip ( self . positions (), self . energies ()): positions = np . array ( positions ) energies = np . array ( energies ) norms = np . linalg . norm ( positions , axis = 1 ) # Create boolean arrays for the conditions cond1 = np . concatenate ([( norms [: - 1 ] < r ) & ( r < norms [ 1 :]), [ False ]]) cond2 = np . concatenate ([[ False ], ( norms [ 1 :] < r ) & ( r < norms [: - 1 ])]) # Get the energies of the neutrons that have been in the shell result_energies += list ( energies [ cond1 ]) + list ( energies [ cond2 ]) return result_energies energy_spectrum_escaped () Get the energy spectrum of the neutrons that escaped the tank. Returns: list [ float ] \u2013 a list of floats. Source code in neutrowater/post/measure.py 206 207 208 209 210 211 212 213 214 215 216 217 def energy_spectrum_escaped ( self ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons that escaped the tank. Returns: a list of floats. \"\"\" return [ neutron . energy for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ] flux ( r ) Get the flux of the neutrons at a given radius r. Parameters: r ( float ) \u2013 radius at which to compute the flux. Returns: float \u2013 a float value of the flux. Source code in neutrowater/post/measure.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def flux ( self , r : float ) -> float : \"\"\" Get the flux of the neutrons at a given radius r. Args: r (float): radius at which to compute the flux. Returns: a float value of the flux. \"\"\" count = 0 for positions in self . positions (): positions = np . array ( positions ) norms = np . linalg . norm ( positions , axis = 1 ) # Count the number of neutrons that have been in the shell count += np . sum (( norms [: - 1 ] < r ) & ( r < norms [ 1 :])) + np . sum ( ( norms [ 1 :] < r ) & ( r < norms [: - 1 ]) ) return count / ( 4 * np . pi * r ** 2 ) number_above_energy ( E ) Get the number of neutrons with energy above a given energy. Parameters: E ( float ) \u2013 energy threshold. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 219 220 221 222 223 224 225 226 227 228 229 def number_above_energy ( self , E : float ) -> int : \"\"\" Get the number of neutrons with energy above a given energy. Args: E (float): energy threshold. Returns: an int. \"\"\" return sum ([ 1 for neutron in self . neutrons if neutron . energies [ 0 ] > E ]) number_absorbed () Get the number of neutrons that were absorbed. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def number_absorbed ( self ) -> int : \"\"\" Get the number of neutrons that were absorbed. Returns: an int. \"\"\" n = 0 for neutron in self . neutrons : if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ): n += 1 return n number_escaped () Get the number of neutrons that escaped the tank. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def number_escaped ( self ) -> int : \"\"\" Get the number of neutrons that escaped the tank. Returns: an int. \"\"\" return sum ( [ 1 for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ], start = 0 , ) number_thermal () Get the number of neutrons that are thermalized. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 85 86 87 88 89 90 91 92 93 94 95 96 def number_thermal ( self ) -> int : \"\"\" Get the number of neutrons that are thermalized. Returns: an int. \"\"\" n = 0 for energies in self . energies (): if energies [ - 1 ] < ( 10 * self . sim . kT ): n += 1 return n number_total () Get the total number of neutrons. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 60 61 62 63 64 65 66 67 def number_total ( self ) -> int : \"\"\" Get the total number of neutrons. Returns: an int. \"\"\" return len ( self . neutrons ) positions () Get the positions of the neutrons. Returns: list [ list [ Vector ]] \u2013 a list where each element is a list of length nNeutrons [[np.ndarray, np.ndarray, ...], [np.ndarray, np.ndarray, ...], ...] Source code in neutrowater/post/measure.py 40 41 42 43 44 45 46 47 48 def positions ( self ) -> list [ list [ Vector ]]: \"\"\" Get the positions of the neutrons. Returns: a list where each element is a list of length nNeutrons [[np.ndarray, np.ndarray, ...], [np.ndarray, np.ndarray, ...], ...] \"\"\" return [ neutron . positions for neutron in self . neutrons ] thermalize_distances () Get the distance of the neutrons where their energy is thermal for the first time. Returns: list \u2013 a list of floats. Source code in neutrowater/post/measure.py 116 117 118 119 120 121 122 123 124 def thermalize_distances ( self ) -> list : \"\"\" Get the distance of the neutrons where their energy is thermal for the first time. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . thermalize_positions ()] thermalize_positions () Get the positions of the neutrons where their energy is thermal for the first time. Returns: list \u2013 a list of np.ndarray. Source code in neutrowater/post/measure.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def thermalize_positions ( self ) -> list : \"\"\" Get the positions of the neutrons where their energy is thermal for the first time. Returns: a list of np.ndarray. \"\"\" thermalize_positions = [] for energies , positions in zip ( self . energies (), self . positions ()): # Get the first element of the list of energies that is less than 10kT res = list ( filter (( lambda val : val < ( 10 * self . sim . kT )), energies )) if len ( res ) > 0 : index = energies . index ( res [ 0 ]) thermalize_positions . append ( positions [ index ]) return thermalize_positions","title":"API Reference"},{"location":"reference/#neutrowater-api","text":"The easiest way to get started with NeutroWater is to look at the Example . NeutroWater includes a Python API that enables running the simulation and analyzing the results. The two public modules are listed and documented below: neutrowater.diffusing_neutrons - Simulation Set-up and Running neutrowater.post - Post Simulation Analysis","title":"NeutroWater API"},{"location":"reference/#simulation-set-up-and-running","text":"","title":"Simulation Set-up and Running"},{"location":"reference/#neutrowaterdiffusing_neutrons","text":"This module provides a class to simulate the diffusion of neutrons in a medium. Classes: Name Description Parameters Class to store the parameters for the simulation. DiffusingNeutrons Class to simulate the diffusion of neutrons in a medium.","title":"neutrowater.diffusing_neutrons"},{"location":"reference/#neutrowater.diffusing_neutrons.DiffusingNeutrons","text":"Class that simulates multiple neutrons from diffusing in a medium. Parameters: p ( Parameters ) \u2013 Parameters for the simulation. Source code in neutrowater/diffusing_neutrons.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class DiffusingNeutrons : \"\"\" Class that simulates multiple neutrons from diffusing in a medium. Args: p (Parameters): Parameters for the simulation. \"\"\" def __init__ ( self , p : Parameters , ): self . kT = ( 1.380649e-23 * p . temperature * 6.24150907 * 10 ** 18 ) # [m^2 kg / (s^2 K) * K * (eV/J) = J*(eV/J) = eV] self . nCollisions = 0 self . mol_struc = p . molecule_structure self . tank = Tank ( p . radius_tank , p . height_tank , p . position_tank ) # For interpolating the total cross section data and computing the # mean-free-path. self . total_processor = TotalProcessor ( p . total_data ) # For interpolating the scattering and absorption cross section and # computing the aborption ratio. self . absorption_processor = AbsorptionProcessor ( p . scattering_data , p . absorption_data ) # Sample from the interpolated energy spectrum spectrum_processor = SpectrumProcessor ( p . spectrum_data ) initial_energies = spectrum_processor . sample ( num_samples = p . nNeutrons ) # Convert the energies MeV -> eV initial_energies = [ energy * 10 ** 6 for energy in initial_energies ] # All neutrons start at the origin initial_positions = [ np . array ([ 0 , 0 , 0 ]) for _ in range ( p . nNeutrons )] self . neutrons = Neutrons ( initial_energies , initial_positions ) # For handling the collisions with the atomic nuclei, hydrogen and oxygen. self . nuclei_masses = p . nuclei_masses # Maxwell-Boltzmann distribution for the thermal energy self . mw = MaxwellBoltzmann ( T = p . temperature ) # For handling the angular distribution of the scattering. self . angular_processor = AngularProcessor ( p . angular_data , p . nuclei_masses ) def diffuse ( self , nCollisions : int ): \"\"\" Let the neutrons diffuse in the medium. Args: nCollisions (int): number of times each neutron collides with an atomic nucleus. \"\"\" self . nCollisions += nCollisions # Using not all cores but 2 less than the total number of cores, tends # to be faster num_processes = multiprocessing . cpu_count () - 2 # Split the neutrons into chunks chunk_size = ( len ( self . neutrons ) + num_processes - 1 ) // num_processes chunks = [ self . neutrons [ i : i + chunk_size ] for i in range ( 0 , len ( self . neutrons ), chunk_size ) ] # Diffuse the chuncks of neutrons in parallel with multiprocessing . Pool ( processes = num_processes ) as pool : results = list ( process_map ( self . _diffuse_chunk , chunks , [ nCollisions ] * len ( chunks )), ) # Update the neutrons list with the results from the parallel processess self . neutrons = [ neutron for chunk in results for neutron in chunk ] def _diffuse_chunk ( self , chunk : Neutrons , nCollisions : int ): \"\"\" Diffuse a chunk of all neutrons in the medium. Args: chunk (Sequence[Neutron]): chunk of neutrons to diffuse nCollisions (int): number of times each neutron collides with an atomic nucleus. Returns: the neutrons after diffusing in the medium. \"\"\" np . random . seed () # Set a new seed for each process return [ self . _diffuse_neutron ( neutron , nCollisions ) for neutron in chunk ] def _diffuse_neutron ( self , neutron : Neutron , nCollisions : int ) -> Neutron : \"\"\" Diffuse a single neutron in the medium. Args: neutron (Neutron): Neutron to diffuse nCollisions (int): number of times the neutron collides with an atomic nucleus. Returns: the neutron after diffusing in the medium. \"\"\" neutron . direction = random_direction () for _ in range ( nCollisions ): if not self . tank . inside ( neutron . position ): break # Sample the distance the neutron travels from an exponential distribution # with mean free path as the scale parameter. l = - self . total_processor . get_mfp ( neutron . energy ) * np . log ( random ()) neutron . travel ( l ) # Determine the nucleus the neutron collides with mass = ( self . nuclei_masses [ 0 ] if random () < self . total_processor . get_ratio ( neutron . energy ) else self . nuclei_masses [ 1 ] ) collision = Collision ( initial_E = neutron . energy , initial_direction = neutron . direction , mass = mass , scattering_cosine = self . angular_processor . get_CM_cosines ( mass , neutron . energy , 1 )[ 0 ], absorption = self . _absorbed ( neutron , self . nuclei_masses . index ( mass )), thermal = neutron . energy < 10 * self . kT , ) # Update the neutron's energy and direction neutron . collide ( collision . energy_loss_frac , collision . scattering_direction ) # If the neutron is absorbed, break the loop if collision . energy_loss_frac == 1 : break return neutron def _absorbed ( self , neutron : Neutron , index : int ) -> bool : \"\"\" Check if the neutron is absorbed by the nucleus. Args: neutron (Neutron): Neutron to check. index (int): index of the nucleus in the molecule. Returns: True if the neutron is absorbed, False otherwise. \"\"\" if ( random () < self . absorption_processor . get_absorption_rates ( neutron . energy )[ index ] ): return True else : return False","title":"DiffusingNeutrons"},{"location":"reference/#neutrowater.diffusing_neutrons.DiffusingNeutrons.diffuse","text":"Let the neutrons diffuse in the medium. Parameters: nCollisions ( int ) \u2013 number of times each neutron collides with an atomic nucleus. Source code in neutrowater/diffusing_neutrons.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def diffuse ( self , nCollisions : int ): \"\"\" Let the neutrons diffuse in the medium. Args: nCollisions (int): number of times each neutron collides with an atomic nucleus. \"\"\" self . nCollisions += nCollisions # Using not all cores but 2 less than the total number of cores, tends # to be faster num_processes = multiprocessing . cpu_count () - 2 # Split the neutrons into chunks chunk_size = ( len ( self . neutrons ) + num_processes - 1 ) // num_processes chunks = [ self . neutrons [ i : i + chunk_size ] for i in range ( 0 , len ( self . neutrons ), chunk_size ) ] # Diffuse the chuncks of neutrons in parallel with multiprocessing . Pool ( processes = num_processes ) as pool : results = list ( process_map ( self . _diffuse_chunk , chunks , [ nCollisions ] * len ( chunks )), ) # Update the neutrons list with the results from the parallel processess self . neutrons = [ neutron for chunk in results for neutron in chunk ]","title":"diffuse"},{"location":"reference/#neutrowater.diffusing_neutrons.Parameters","text":"Class to store the parameters for the simulation. Parameters: nNeutrons ( int ) \u2013 Number of neutrons to simulate molecule_structure ( Sequence , default: (2, 1) ) \u2013 number of atoms in the molecule. nuclei_masses ( Sequence , default: (1, 16) ) \u2013 Masses of the nuclei in the molecule, should be in the same order as the molecule_structure. radius_tank ( float , default: 1 ) \u2013 Radius of the tank in meters. height_tank ( float , default: 1 ) \u2013 Height of the tank in meters. position_tank ( ndarray , default: (0.0, 0.0, 0.0) ) \u2013 Position of the tank. temperature ( float , default: 293 ) \u2013 Temperature [K] of the medium. Source code in neutrowater/diffusing_neutrons.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @dataclass class Parameters : \"\"\" Class to store the parameters for the simulation. Args: nNeutrons (int): Number of neutrons to simulate molecule_structure (Sequence): number of atoms in the molecule. nuclei_masses (Sequence): Masses of the nuclei in the molecule, should be in the same order as the molecule_structure. radius_tank (float): Radius of the tank in meters. height_tank (float): Height of the tank in meters. position_tank (np.ndarray): Position of the tank. temperature (float): Temperature [K] of the medium. \"\"\" nNeutrons : int molecule_structure : Sequence = ( 2 , 1 ) nuclei_masses : Sequence = ( 1 , 16 ) radius_tank : float = 1 height_tank : float = 1 position_tank : tuple = ( 0.0 , 0.0 , 0.0 ) temperature : float = 293 def __post_init__ ( self ): files = resources . files ( data ) self . total_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"h_cross_t.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"o_cross_t.txt\" , sep = r \"\\s+\" ), ] self . scattering_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"h_cross_s.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"o_cross_s.txt\" , sep = r \"\\s+\" ), ] self . absorption_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"h_cross_a.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"o_cross_a.txt\" , sep = r \"\\s+\" ), ] self . angular_data : Sequence [ pd . DataFrame ] = [ pd . read_csv ( files / \"H_angular.txt\" , sep = r \"\\s+\" ), pd . read_csv ( files / \"O_angular.txt\" , sep = r \",\" ), ] self . spectrum_data : pd . DataFrame = pd . read_csv ( files / \"neutron_spectrum_normalized.txt\" , sep = \",\" )","title":"Parameters"},{"location":"reference/#post-simulation-analysis","text":"","title":"Post Simulation Analysis"},{"location":"reference/#neutrowaterpostplot","text":"This module provides a function to plot the trajectories of the neutrons. Functions: Name Description trajectories Show the trajectories of the neutrons.","title":"neutrowater.post.plot"},{"location":"reference/#neutrowater.post.plot.trajectories","text":"Show the trajectories of the neutrons. Parameters: diffusing_neutrons ( DiffusingNeutrons ) \u2013 Object of the class DiffusingNeutrons. Source code in neutrowater/post/plot.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def trajectories ( diffusing_neutrons : DiffusingNeutrons ): \"\"\" Show the trajectories of the neutrons. Args: diffusing_neutrons (DiffusingNeutrons): Object of the class DiffusingNeutrons. \"\"\" df = diffusing_neutrons measurer = measure . Measurer ( df ) radius = df . tank . radius height = df . tank . height tank_position = df . tank . position fig = plt . figure ( figsize = ( 8 , 8 )) ax = fig . add_subplot ( 111 , projection = \"3d\" ) for position in measurer . positions (): x = [ p [ 0 ] for p in position ] y = [ p [ 1 ] for p in position ] z = [ p [ 2 ] for p in position ] ax . plot ( x , y , z , c = \"k\" , linewidth = 0.5 , alpha = 0.7 ) ax . plot ( 0 , 0 , 0 , \"o\" , c = \"r\" ) ax . set_xlabel ( \"$x(m)$\" , fontsize = 16 ) ax . set_ylabel ( \"$y(m)$\" , fontsize = 16 ) ax . set_box_aspect ( aspect = None , zoom = 2 ) ax . set_zlabel ( \"$z(m)$\" , fontsize = 16 ) ax . set_title ( \"Neutron trajectories\" ) ax . set_xlim ( - 0.4 , 0.4 ) ax . set_ylim ( - 0.4 , 0.4 ) ax . axis ( \"off\" ) ax . margins ( x = 0 , y = 0 ) ax . spines [[ \"right\" , \"top\" ]] . set_visible ( False ) if df . tank is not None : u = np . linspace ( 0 , 2 * np . pi , 100 ) v = np . linspace ( 0 , height , 100 ) x = radius * np . outer ( np . cos ( u ), np . ones_like ( v )) + tank_position [ 0 ] y = radius * np . outer ( np . sin ( u ), np . ones_like ( v )) + tank_position [ 1 ] z = ( np . outer ( np . ones_like ( u ), v ) - height / 2 + tank_position [ 2 ] ) # Adjust the height of the cylinder ax . plot_surface ( x , y , z , color = \"cornflowerblue\" , alpha = 0.3 ) plt . show ()","title":"trajectories"},{"location":"reference/#neutrowaterpostmeasure","text":"This module provides a class to measure the properties of the neutrons. Classes: Name Description Measurer Class to measure the properties of the neutrons after the simulation.","title":"neutrowater.post.measure"},{"location":"reference/#neutrowater.post.measure.Measurer","text":"Class to measure the properties of the neutrons after the simulation. Methods: Name Description positions Get the positions of the neutrons. energies Get the energies of the neutrons. number_total Get the total number of neutrons. number_escaped Get the number of neutrons that escaped the tank. number_thermal Get the number of neutrons that are thermalized. thermalize_positions Get the positions of the neutrons where their energy is thermal for the first time. thermalize_distances Get the distance of the neutrons where their energy is thermal for the first time. number_absorbed Get the number of neutrons that were absorbed. absorbed_positions Get the positions of the neutrons that were absorbed. absorbed_distances Get the distances of the neutrons that were absorbed. flux Get the flux of the neutrons at a given radius r. energy_spectrum Get the energy spectrum of the neutrons at a given radius r. energy_spectrum_escaped Get the energy spectrum of the neutrons that escaped the tank. number_above_energy Get the number of neutrons with energy above a given energy. Source code in neutrowater/post/measure.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class Measurer : \"\"\"Class to measure the properties of the neutrons after the simulation. Methods: positions: Get the positions of the neutrons. energies: Get the energies of the neutrons. number_total: Get the total number of neutrons. number_escaped: Get the number of neutrons that escaped the tank. number_thermal: Get the number of neutrons that are thermalized. thermalize_positions: Get the positions of the neutrons where their energy is thermal for the first time. thermalize_distances: Get the distance of the neutrons where their energy is thermal for the first time. number_absorbed: Get the number of neutrons that were absorbed. absorbed_positions: Get the positions of the neutrons that were absorbed. absorbed_distances: Get the distances of the neutrons that were absorbed. flux: Get the flux of the neutrons at a given radius r. energy_spectrum: Get the energy spectrum of the neutrons at a given radius r. energy_spectrum_escaped: Get the energy spectrum of the neutrons that escaped the tank. number_above_energy: Get the number of neutrons with energy above a given energy. \"\"\" def __init__ ( self , sim : DiffusingNeutrons ): self . neutrons = sim . neutrons self . sim = sim def positions ( self ) -> list [ list [ Vector ]]: \"\"\" Get the positions of the neutrons. Returns: a list where each element is a list of length nNeutrons [[np.ndarray, np.ndarray, ...], [np.ndarray, np.ndarray, ...], ...] \"\"\" return [ neutron . positions for neutron in self . neutrons ] def energies ( self ) -> list [ list [ float ]]: \"\"\" Get the energies of the neutrons. Returns: a list where each element is a list of length nNeutrons [[float, float, ...], [float, float, ...], ...] \"\"\" return [ neutron . energies for neutron in self . neutrons ] def number_total ( self ) -> int : \"\"\" Get the total number of neutrons. Returns: an int. \"\"\" return len ( self . neutrons ) def number_escaped ( self ) -> int : \"\"\" Get the number of neutrons that escaped the tank. Returns: an int. \"\"\" return sum ( [ 1 for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ], start = 0 , ) def number_thermal ( self ) -> int : \"\"\" Get the number of neutrons that are thermalized. Returns: an int. \"\"\" n = 0 for energies in self . energies (): if energies [ - 1 ] < ( 10 * self . sim . kT ): n += 1 return n def thermalize_positions ( self ) -> list : \"\"\" Get the positions of the neutrons where their energy is thermal for the first time. Returns: a list of np.ndarray. \"\"\" thermalize_positions = [] for energies , positions in zip ( self . energies (), self . positions ()): # Get the first element of the list of energies that is less than 10kT res = list ( filter (( lambda val : val < ( 10 * self . sim . kT )), energies )) if len ( res ) > 0 : index = energies . index ( res [ 0 ]) thermalize_positions . append ( positions [ index ]) return thermalize_positions def thermalize_distances ( self ) -> list : \"\"\" Get the distance of the neutrons where their energy is thermal for the first time. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . thermalize_positions ()] def number_absorbed ( self ) -> int : \"\"\" Get the number of neutrons that were absorbed. Returns: an int. \"\"\" n = 0 for neutron in self . neutrons : if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ): n += 1 return n def absorbed_positions ( self ) -> list [ Vector ]: \"\"\" Get the positions of the neutrons that were absorbed. Returns: a list of np.ndarray. \"\"\" return [ neutron . positions [ - 1 ] for neutron in self . neutrons if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ) ] def absorbed_distances ( self ) -> list [ np . float64 ]: \"\"\" Get the distances of the neutrons that were absorbed. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . absorbed_positions ()] def flux ( self , r : float ) -> float : \"\"\" Get the flux of the neutrons at a given radius r. Args: r (float): radius at which to compute the flux. Returns: a float value of the flux. \"\"\" count = 0 for positions in self . positions (): positions = np . array ( positions ) norms = np . linalg . norm ( positions , axis = 1 ) # Count the number of neutrons that have been in the shell count += np . sum (( norms [: - 1 ] < r ) & ( r < norms [ 1 :])) + np . sum ( ( norms [ 1 :] < r ) & ( r < norms [: - 1 ]) ) return count / ( 4 * np . pi * r ** 2 ) def energy_spectrum ( self , r : float ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons at a given radius r. Args: r (float): radius at which to compute the energy spectrum. Returns: a list of floats. \"\"\" result_energies = [] for positions , energies in zip ( self . positions (), self . energies ()): positions = np . array ( positions ) energies = np . array ( energies ) norms = np . linalg . norm ( positions , axis = 1 ) # Create boolean arrays for the conditions cond1 = np . concatenate ([( norms [: - 1 ] < r ) & ( r < norms [ 1 :]), [ False ]]) cond2 = np . concatenate ([[ False ], ( norms [ 1 :] < r ) & ( r < norms [: - 1 ])]) # Get the energies of the neutrons that have been in the shell result_energies += list ( energies [ cond1 ]) + list ( energies [ cond2 ]) return result_energies def energy_spectrum_escaped ( self ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons that escaped the tank. Returns: a list of floats. \"\"\" return [ neutron . energy for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ] def number_above_energy ( self , E : float ) -> int : \"\"\" Get the number of neutrons with energy above a given energy. Args: E (float): energy threshold. Returns: an int. \"\"\" return sum ([ 1 for neutron in self . neutrons if neutron . energies [ 0 ] > E ])","title":"Measurer"},{"location":"reference/#neutrowater.post.measure.Measurer.absorbed_distances","text":"Get the distances of the neutrons that were absorbed. Returns: list [ float64 ] \u2013 a list of floats. Source code in neutrowater/post/measure.py 155 156 157 158 159 160 161 162 def absorbed_distances ( self ) -> list [ np . float64 ]: \"\"\" Get the distances of the neutrons that were absorbed. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . absorbed_positions ()]","title":"absorbed_distances"},{"location":"reference/#neutrowater.post.measure.Measurer.absorbed_positions","text":"Get the positions of the neutrons that were absorbed. Returns: list [ Vector ] \u2013 a list of np.ndarray. Source code in neutrowater/post/measure.py 141 142 143 144 145 146 147 148 149 150 151 152 153 def absorbed_positions ( self ) -> list [ Vector ]: \"\"\" Get the positions of the neutrons that were absorbed. Returns: a list of np.ndarray. \"\"\" return [ neutron . positions [ - 1 ] for neutron in self . neutrons if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ) ]","title":"absorbed_positions"},{"location":"reference/#neutrowater.post.measure.Measurer.energies","text":"Get the energies of the neutrons. Returns: list [ list [ float ]] \u2013 a list where each element is a list of length nNeutrons [[float, float, ...], [float, float, ...], ...] Source code in neutrowater/post/measure.py 50 51 52 53 54 55 56 57 58 def energies ( self ) -> list [ list [ float ]]: \"\"\" Get the energies of the neutrons. Returns: a list where each element is a list of length nNeutrons [[float, float, ...], [float, float, ...], ...] \"\"\" return [ neutron . energies for neutron in self . neutrons ]","title":"energies"},{"location":"reference/#neutrowater.post.measure.Measurer.energy_spectrum","text":"Get the energy spectrum of the neutrons at a given radius r. Parameters: r ( float ) \u2013 radius at which to compute the energy spectrum. Returns: list [ float ] \u2013 a list of floats. Source code in neutrowater/post/measure.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def energy_spectrum ( self , r : float ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons at a given radius r. Args: r (float): radius at which to compute the energy spectrum. Returns: a list of floats. \"\"\" result_energies = [] for positions , energies in zip ( self . positions (), self . energies ()): positions = np . array ( positions ) energies = np . array ( energies ) norms = np . linalg . norm ( positions , axis = 1 ) # Create boolean arrays for the conditions cond1 = np . concatenate ([( norms [: - 1 ] < r ) & ( r < norms [ 1 :]), [ False ]]) cond2 = np . concatenate ([[ False ], ( norms [ 1 :] < r ) & ( r < norms [: - 1 ])]) # Get the energies of the neutrons that have been in the shell result_energies += list ( energies [ cond1 ]) + list ( energies [ cond2 ]) return result_energies","title":"energy_spectrum"},{"location":"reference/#neutrowater.post.measure.Measurer.energy_spectrum_escaped","text":"Get the energy spectrum of the neutrons that escaped the tank. Returns: list [ float ] \u2013 a list of floats. Source code in neutrowater/post/measure.py 206 207 208 209 210 211 212 213 214 215 216 217 def energy_spectrum_escaped ( self ) -> list [ float ]: \"\"\" Get the energy spectrum of the neutrons that escaped the tank. Returns: a list of floats. \"\"\" return [ neutron . energy for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ]","title":"energy_spectrum_escaped"},{"location":"reference/#neutrowater.post.measure.Measurer.flux","text":"Get the flux of the neutrons at a given radius r. Parameters: r ( float ) \u2013 radius at which to compute the flux. Returns: float \u2013 a float value of the flux. Source code in neutrowater/post/measure.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def flux ( self , r : float ) -> float : \"\"\" Get the flux of the neutrons at a given radius r. Args: r (float): radius at which to compute the flux. Returns: a float value of the flux. \"\"\" count = 0 for positions in self . positions (): positions = np . array ( positions ) norms = np . linalg . norm ( positions , axis = 1 ) # Count the number of neutrons that have been in the shell count += np . sum (( norms [: - 1 ] < r ) & ( r < norms [ 1 :])) + np . sum ( ( norms [ 1 :] < r ) & ( r < norms [: - 1 ]) ) return count / ( 4 * np . pi * r ** 2 )","title":"flux"},{"location":"reference/#neutrowater.post.measure.Measurer.number_above_energy","text":"Get the number of neutrons with energy above a given energy. Parameters: E ( float ) \u2013 energy threshold. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 219 220 221 222 223 224 225 226 227 228 229 def number_above_energy ( self , E : float ) -> int : \"\"\" Get the number of neutrons with energy above a given energy. Args: E (float): energy threshold. Returns: an int. \"\"\" return sum ([ 1 for neutron in self . neutrons if neutron . energies [ 0 ] > E ])","title":"number_above_energy"},{"location":"reference/#neutrowater.post.measure.Measurer.number_absorbed","text":"Get the number of neutrons that were absorbed. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def number_absorbed ( self ) -> int : \"\"\" Get the number of neutrons that were absorbed. Returns: an int. \"\"\" n = 0 for neutron in self . neutrons : if len ( neutron . positions ) < self . sim . nCollisions and self . sim . tank . inside ( neutron . position ): n += 1 return n","title":"number_absorbed"},{"location":"reference/#neutrowater.post.measure.Measurer.number_escaped","text":"Get the number of neutrons that escaped the tank. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def number_escaped ( self ) -> int : \"\"\" Get the number of neutrons that escaped the tank. Returns: an int. \"\"\" return sum ( [ 1 for neutron in self . neutrons if not self . sim . tank . inside ( neutron . position ) ], start = 0 , )","title":"number_escaped"},{"location":"reference/#neutrowater.post.measure.Measurer.number_thermal","text":"Get the number of neutrons that are thermalized. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 85 86 87 88 89 90 91 92 93 94 95 96 def number_thermal ( self ) -> int : \"\"\" Get the number of neutrons that are thermalized. Returns: an int. \"\"\" n = 0 for energies in self . energies (): if energies [ - 1 ] < ( 10 * self . sim . kT ): n += 1 return n","title":"number_thermal"},{"location":"reference/#neutrowater.post.measure.Measurer.number_total","text":"Get the total number of neutrons. Returns: int \u2013 an int. Source code in neutrowater/post/measure.py 60 61 62 63 64 65 66 67 def number_total ( self ) -> int : \"\"\" Get the total number of neutrons. Returns: an int. \"\"\" return len ( self . neutrons )","title":"number_total"},{"location":"reference/#neutrowater.post.measure.Measurer.positions","text":"Get the positions of the neutrons. Returns: list [ list [ Vector ]] \u2013 a list where each element is a list of length nNeutrons [[np.ndarray, np.ndarray, ...], [np.ndarray, np.ndarray, ...], ...] Source code in neutrowater/post/measure.py 40 41 42 43 44 45 46 47 48 def positions ( self ) -> list [ list [ Vector ]]: \"\"\" Get the positions of the neutrons. Returns: a list where each element is a list of length nNeutrons [[np.ndarray, np.ndarray, ...], [np.ndarray, np.ndarray, ...], ...] \"\"\" return [ neutron . positions for neutron in self . neutrons ]","title":"positions"},{"location":"reference/#neutrowater.post.measure.Measurer.thermalize_distances","text":"Get the distance of the neutrons where their energy is thermal for the first time. Returns: list \u2013 a list of floats. Source code in neutrowater/post/measure.py 116 117 118 119 120 121 122 123 124 def thermalize_distances ( self ) -> list : \"\"\" Get the distance of the neutrons where their energy is thermal for the first time. Returns: a list of floats. \"\"\" return [ np . linalg . norm ( pos ) for pos in self . thermalize_positions ()]","title":"thermalize_distances"},{"location":"reference/#neutrowater.post.measure.Measurer.thermalize_positions","text":"Get the positions of the neutrons where their energy is thermal for the first time. Returns: list \u2013 a list of np.ndarray. Source code in neutrowater/post/measure.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def thermalize_positions ( self ) -> list : \"\"\" Get the positions of the neutrons where their energy is thermal for the first time. Returns: a list of np.ndarray. \"\"\" thermalize_positions = [] for energies , positions in zip ( self . energies (), self . positions ()): # Get the first element of the list of energies that is less than 10kT res = list ( filter (( lambda val : val < ( 10 * self . sim . kT )), energies )) if len ( res ) > 0 : index = energies . index ( res [ 0 ]) thermalize_positions . append ( positions [ index ]) return thermalize_positions","title":"thermalize_positions"},{"location":"results/","text":"Results 1 Flux 2 Energy Spectrum 3 Escaping Neutrons","title":"Results"},{"location":"results/#results","text":"","title":"Results"},{"location":"results/#1-flux","text":"","title":"1 Flux"},{"location":"results/#2-energy-spectrum","text":"","title":"2 Energy Spectrum"},{"location":"results/#3-escaping-neutrons","text":"","title":"3 Escaping Neutrons"},{"location":"theory/","text":"Theory and Methodology 1. General Program Flow The software conducts a collision-driven Monte Carlo simulation, where it simulates each particle individually. Prior to running the simulation, it must undergo initialization, which involves the following steps: Interpolating the total, absorbtion, and scattering cross section data. Interpolating data of the initial energy distribution of the neutrons. Sampling the initial neutron energies from the energy distribution. Setting the initial position and energies of the neutrons. Setting the position and size of the tank. The initial spectrum is discussed in Initial Energy Spectrum , the method of sampling from a distribution is described in Monte Carlo Sampling , and the interpolation of distributions in Interpolation . After the initializing, the actual simulation of the diffusing neutrons can start. Each neutron's energy and position is updated consecutively which consists of the following steps: Give the neutron a random direction. Check if the neutron is inside the tank, if false end the loop else continue. Get the total cross section corresponding to the current energy of the neutron. Determine the nuclide with which the neutron collides. Check if the the neutron has a thermal energy. Compute the mean free path of the neutron and sample the distance to the next collision. Determine the type of reaction. If it is absorption, end the loop; if it is elastic scattering, proceed. Sample a direction from the angular distribution and compute the associated energy loss fraction. Update the Neutron's position and energy. Repeat steps 2-9 until the neutron either escaped or is absorbed. Each step is discussed in more detail in the following sections: Steps Section 2 Geometry 3-4 Cross Sections 5 Thermal Motion 6 Distance To Next Collision 7 Neutron Interactions 8-9 Handling Scattering Interaction In the simulation, positions and energies of the neutrons are stored. Several properties can be computed and measured from this data post-simulation. The procedure of measuring these properties is described in Measuring Quantities . 2. Neutron Physics 2.1 Initial Energy Spectrum The neutron source used is a mixture of americium-241 and beryllium-9. The following reactions take place in the source: \\[\\begin{equation} ^{241}_{95}\\text{Am} \\ \\rightarrow \\ ^{237}_{93}\\text{Np} \\ + \\ ^4_2\\text{He}, \\end{equation}\\] \\[\\begin{equation} ^4_2\\text{He} \\ + \\ ^9_4\\text{Be} \\ \\rightarrow \\ ^{12}_6\\text{C} \\ + \\ ^1_0\\text{n}. \\end{equation}\\] The first reaction involves the \\( \\alpha- \\) decay of the americium. The \\( \\alpha \\) particles have a probability of about \\( 10^{-4}\\) to undergo fusion with the berylium, described by the second reaction. This reaction leads to the emmission of neutrons with energies between 3 and 10 MeV. We use the Am-Be energy spectrum (Figure 1) from the ISO 8529-1 standard for sampling the initial energies of the neutrons. Figure 1: ISO neutron spectrum for Am-Be. The neutron spectrum is interpolated to serve as a probability distribution of energies \\( P(\\text{Energy}) \\) . This interpolation and subsequent sampling follow the methodology described in Interpolation and Monte Carlo Sampling respectively. The interpolated initial neutron energy spectrum from the Am-Be source is shown in Figure 2. Figure 2: Interpolated ISO neutron spectrum for Am-Be. 2.2 Cross Sections The cross section indicates the likelihood of a particular interaction occurring between two particles. It is influenced by two main factors: the types of particles involved and their energies. In our scenario, there are two possible combinations of particles in an interaction: a neutron with an H-nucleus and a neutron with an O-nucleus. Unfortunately, it's not possible to calculate the cross section as a function of energy analytically. However, there is an abundance of freely accessible nuclear data available to everyone. In the program, cross section data from ENDF/B is used an interpolated following the procedure outlined in Interpolation . In various reactions, different cross sections are involved. To proceed, we employ the following notations: Notation Description \\(\\sigma_{H, tot}, \\sigma_{O, tot}\\) Total cross section for the specified nuclide. \\(\\sigma_{H, s}, \\sigma_{O, s}\\) Scattering cross section for the specified nuclide. \\(\\sigma_{H, a}, \\sigma_{O, a}\\) Absorption cross section for the specified nuclide. \\(\\Sigma_{H_2O}, \\Sigma_{H}, \\Sigma_{O}\\) Total macroscopic for the specified nuclide or molecule. The theory behind these reactions is described in detail in Neutron Interactions . For each type of cross section and nuclide there are separate datafiles. Total macroscopic cross section for a molecule can be computed as follows: \\[\\begin{equation} \\Sigma = \\sum_i N_i \\sigma_i, \\end{equation}\\] where \\(N_i\\) is the atomic density of atoms of type \\(i\\) : \\[\\begin{equation} N_i = \\frac{\\rho N_a}{M} n_i, \\end{equation}\\] where \\(\\rho\\) is the density of the compound, \\(M\\) the molecular weight, \\(N_a\\) Avogrado's constant, and \\(n_i\\) the number of atoms of type \\(i\\) in the molecule. Thus, the total macrocscopic cross section for \\(H_2O\\) is given by: \\[\\begin{equation} \\Sigma_{H_2O} = \\frac{\\rho_{H_20} N_a}{M_{H_20}} (2 \\sigma_{H, t} + \\sigma_{O, t}). \\end{equation}\\] The cross sections in barns ( \\(10^{-28} m^2\\) ) as a function of neutron energy for the O and H nuclide are shown in Figure 3 and 4. Figure 3: Hydrogen cross sections in barns at temperature T=300K. Figure 4: Oxygen cross sections in barns at temperature T=300K. 2.3 Distance to Next Collision The distance to the next collision \\(l\\) follows a distribution function given by: \\[\\begin{equation} p(l)dl=\\Sigma e^{-\\Sigma l}dl, \\end{equation}\\] where \\(\\Sigma\\) is the total macroscopic cross section of an arbitrary material. Integrating both sides to some distance \\(l\\) gives: \\[\\begin{equation} \\int_0^l dl'p(l') = 1 - e^{\\Sigma l}. \\end{equation}\\] As the probability distribution is normalized, we can set the this cummulative distribution to a uniformly distributed random number \\(\\xi\\) on the interval \\( [0, 1) \\) . Isolating \\(l \\) and using that in this case \\(\\Sigma \\equiv \\Sigma_{H_2O} \\) , gives us a formula for sampling the distance to the next collision: \\[\\begin{equation} l = - \\lambda \\ln{\\xi}, \\end{equation}\\] where \\(\\lambda \\) is the mean-free-path which is given by \\[\\begin{equation} \\lambda = 1 / \\Sigma_{H_2O}. \\end{equation}\\] The mean-free-path as a function of neutron energy is shown in Figure 5. Figure 5: Mean-free-path in water as a function of neutron energy. 2.4 Neutron Interactions To determine the type of reaction involving a nuclide, we initially identify which type of nuclide the neutron interacts with, either \\( H\\) or \\( O\\) . The probability of the neutron interacting with H is determined by: \\[\\begin{equation} P(H) = \\frac{\\Sigma_{H_2}}{\\Sigma_{H_2O}} = \\frac{2\\sigma_{H,tot} }{2\\sigma_{H, tot} + \\sigma_{O, tot}}. \\end{equation}\\] If \\(\\xi < P(H)\\) , where \\(\\xi\\) is another uniformly distributed random number on the interval \\( [0, 1) \\) , the neutron interacts with an \\( H \\) nuclide; otherwise, it interacts with an \\( O \\) nuclide. Since the cross sections depend on the energy of the neutron, \\(P(H) \\) also varies accordingly. The dependence of \\( P(H) \\) on neutron energy is depicted in Figure 6. Figure 6: Probability of H collision as a function of neutron energy. Once the nuclide of interaction is determined, it is necessary to consider the reactions that can take place. Firstly we check absorbtion. The probability for absorbtion is given by: \\[\\begin{equation} P(\\text{absorbtion}) = \\frac{\\sigma_{i,a}}{\\sigma_{i,tot}}, \\end{equation}\\] where \\( \\sigma_{i, tot} \\) and \\( \\sigma_{i, a} \\) are the total and absorbtion cross section of the previously identified nuclide respectively. Again, if \\(\\xi < P(\\text{absorbtion})\\) , then the neutron is absorbed by the nuclide. Absorption results in the complete dissipation of the neutron's energy and we proceed to simulate the next neutron. The absorption probability \\(P(\\text{absorbtion})\\) as a function of neutron energy for H and O are shown in Figure 7 and 8 respectively. Figure 7: Absorbtion probability of H as a function of neutron energy. Figure 8: Absorbtion probability of O as a function of neutron energy. If the criteria mentioned above is not met, we consider a scattering interaction. This interaction leads to a reduction in the neutron's energy, determined by the outgoing angle. This angle is sampled from a distribution specific to the nuclide in question. The process of sampling the angle and computing the neutron's new direction and energy is elaborated upon in the Section Handling Scattering Interaction . 2.5 Handling Scattering Interaction A scattering interaction involving a neutron and nuclide results in an energy loss, which depends on the outgoing angle of the neutron. At lower (thermal) neutron energies, there is notable relative motion between the neutron and the nuclide. The treatment of this scenario is discussed in the Section Thermal Motion . However, at higher energies, it is a reasonable approximation to consider the nuclides as stationary. We can extract the outgoing angles from datasets containing angular distributions sourced from ENDF/B . These distributions, which vary with increasing neutron energies, are defined by Legendre polynomials and are provided in the center-of-mass frame. The representation of these angular distributions using Legendre polynomials is detailed in the ENDF-6 Formats Manual , which we will briefly explain in Angular Distributions . With this angle the new energy and direction of the neutron can be computed as described in Transforming Coordinates . 2.5.1 Angular Distributions The angular distributions depend on the energy \\(E\\) in the labframe and the cosine of the outgoing angle in the center-of-mass frame \\(\\mu\\) . The distributions are normalized: \\[\\begin{equation} \\int^1_{-1} f(\\mu, E) d\\mu = 1. \\end{equation}\\] We assume that the angular distributions of the scattered neutrons have azimuthal symmetry. This implies that we can uniformly select the azimuthal angle \\(\\phi\\) from the range \\( [0,2\\pi) \\) . The distributions \\( f(\\mu, E) \\) are represented as Legendre polynomials: \\[\\begin{equation} f(\\mu, E) = \\sum_{l=0}^{NL} \\frac{2l+1}{2} a_l(E) P_l(\\mu), \\end{equation}\\] where \\( l\\) is the order of the Legendre polynomial, \\(a_l \\) the \\(l^{th}\\) Legendre polynomial coefficient, and \\( NL \\) the number of Legendre polynomials that represent the distribution. Below in Figure 9 and 10 the angular distributions are plotted for varying neutron energy. Figure 9: Hydrogen scattering angular distribution for varying energy. Figure 10: Oxygen scattering angular distribution for varying energy. EXPLANATION ABOVE FIGURES The neutron energy distributions are discretely spaced for each incoming neutron energy \\(E_i \\) , requiring a selection between the distribution corresponding to the energy immediately above or below the current neutron energy. This is done by defining an interpolation factor: \\[\\begin{equation} f = \\frac{E - E_i}{E_{i+1} - E_i}, \\end{equation}\\] where \\( E \\) is the incoming energy of the neutron. We designate \\(k\\) as the selected distribution index. If \\( \\xi > f \\) , then \\(k=i\\) ; otherwise, \\(k=i+1\\) , where \\( \\xi \\) is a uniform distributed random number on the interval \\( [0, 1) \\) . The cosine of the scattering angle \\(\\mu \\) in the center-of-mass (CM) frame is sampled from the angular distribution corresponding to \\(E_k\\) . 2.5.2 Transforming Coordinates From the cosine of the scattering angle in the CM frame \\(\\mu \\) , the secondary velocity of the neutron can be calculated analytically. We start by considering the velocity of the center-of-mass which is given by: \\[\\begin{equation} \\mathbf{v}_{cm} = \\frac{\\mathbf{v}_n + A \\mathbf{v}_t}{1+A} = \\frac{\\mathbf{v}_n}{1+A}, \\end{equation}\\] where A is the mass of the target nuclide, \\( \\mathbf{v}_n \\) the initial velocity of the neutron, and \\( \\mathbf{v}_t \\) is the velocity of the target nuclide. For energies significantly surpassing thermal energy, \\( \\mathbf{v}_t \\) can be considered negligble. The velocity of the neutron can now be transformed to the CM frame: \\[\\begin{equation} \\mathbf{V}_n = \\mathbf{v}_n - \\mathbf{v}_{cm}, \\end{equation}\\] where the capital letter \\( \\mathbf{V} \\) denotes the CM frame. If we express the post-collision direction in the CM frame as \\( \\mathbf{\\Omega}' = (u', v', w') \\) , the components are given by: \\[\\begin{equation} \\begin{aligned} &u' = \\sin{\\theta} \\cos{\\phi} \\\\ &v' = \\sin{\\theta} \\sin{\\phi} \\\\ &w'= \\cos{\\theta} \\end{aligned} \\end{equation}\\] where \\( \\phi \\) is the azimuthal angle and \\( \\theta = \\cos^{-1}(\\mu) \\) . We assume azimuthal symmetry, so \\( \\phi \\) can be sampled from a random uniformly distributed interval \\( [0, 2\\pi) \\) . Finally, transforming back to the lab frame results in the new velocity of the neutron: \\[\\begin{equation} \\mathbf{v}'_n = ||\\mathbf{V}_n|| \\mathbf{\\Omega}' + \\mathbf{v}_{cm}. \\end{equation}\\] The relation between the post- and pre-collision neutron energy in the labframe can be computed as \\[\\begin{equation} E' = \\frac{||\\mathbf{v}'_n||^2}{||\\mathbf{v}_n||^2} E, \\end{equation}\\] and the relation between the old and new position is given by: \\[\\begin{equation} \\mathbf{r}'_n = \\mathbf{r}_n + \\frac{\\mathbf{v}'_n}{||\\mathbf{v}'_n||} l,\\end{equation}\\] where \\( l \\) is obtained following the methodology outlined in Distance to Next Collision . 2.6 Thermal Motion When the energy of the neutron approaches thermal energies, the target nuclide cannot be assumed to be at rest. The target nucleus will have motion associated with its thermal vibration. Thermal motion has an effect on the cross sections and the secondary angular distribution. In The OpenMC Monte Carlo Code a method is described for sampling the velocity of the target nucleus to be used in the elastic scattering kinematic equations described in Handling Scattering Interaction . For the activation process we are mainly interested in the high energy neutrons. For simplicity in the simulation, thermal neutron energies are drawn from a Maxwell-Boltzmann distribution. Furthermore, the resulting direction of a neutron from a scattering reaction is chosen to be random. A neutron is considered thermal when it reaches an energy below the threshold of \\( 10 K_B T \\approx 0.252 \\ eV\\) , where \\( K_B \\) is Boltzmann's constant and \\(T \\) is the temperature of the water. The Maxwell-Boltzmann distribution for \\( T = 293 K \\) is used in the simulation and shown in Figure 11. Figure 11: Maxwell-Boltzmann distribution of energies for T = 293 K. The thermal energy threshold used in the simulation is shown with the dashed line. 3 Geometry The geometry of the experiment is shown in Figure 12. In the simulation the neutron source is placed at the origin. The water tank of radius \\( R\\) and height \\( h \\) is placed at position \\( \\mathbf{r}_t\\) such that the neutrons diffuse from the correct initial position. Figure 12: Simplified figure of the neutron source in the water tank. The insert containing the target can be moved in the radial direction through slots in the top plate of the water tank. A Neutron at position \\( \\mathbf{r}_n \\) is inside the tank if the following conditions are true: \\[\\begin{equation} \\begin{aligned} & |\\mathbf{r}_n - \\mathbf{r}_t |_{xy} < R \\\\ & |r_{n_z} - r_{t_z} | < h/2, \\\\ \\end{aligned} \\end{equation}\\] where the notation \\( | \\mathbf{r} |_{xy} = \\sqrt{r_x^2 + r_y^2} \\) is used. If these conditions are not met, the neutron is flagged as escaped and the simulation proceeds with simulating the next neutron. 4 Monte Carlo Sampling In the initilization the energies of the neutrons are sampled from the distribution shown in Figure 2. The secondary angles of the neutrons in a scattering interaction are sampled from angular distributions on the fly. Some examples of these angular distributions are shown in Figure 10. Finally, when a neutron reaches the thermal energy threshold, its energies are sampled from the Boltzmann distribution shown in Figure 11. The Monte Carlo method used in the simulation is rejection sampling. For simplicity, the proposal distribution is chosen to be a uniform distribution on the interval \\([0, 1) \\) for each of the sampling processes. The following steps are performed to sample a point from a PDF \\(f\\) : Sample y uniformly on the interval \\([0, 1) \\) and \\( x\\) between the bounds of the \\( f \\) . Compute \\( P = f(x) \\) . If \\( y \\leq P \\) stop the process and return \\(x\\) , else go back to step 1. Figure 13 illustrates a large sample obtained from an angular distribution using rejection sampling. This figure is meant to demonstrate the sampling method, as in the simulation, only one secondary angle is sampled per elastic collision. Figure 13: Sample of size N = 10000 obtained from the angular distribution of an elastic O-n collision at E = 5.48e6 eV using rejection sampling. 5 Interpolation 6 Measuring Quantities For neutron activation, we are interested in the flux and the energy spectrum of the neutrons at varying radius in the tank. These quantities can be computed from the positions of the neutrons and the energies of the neutrons at each collisions sight in the tank, which are stored after running the simulation. 6.1 Flux 6.2 Energy Spectrum","title":"Theory and Methodology"},{"location":"theory/#theory-and-methodology","text":"","title":"Theory and Methodology"},{"location":"theory/#1-general-program-flow","text":"The software conducts a collision-driven Monte Carlo simulation, where it simulates each particle individually. Prior to running the simulation, it must undergo initialization, which involves the following steps: Interpolating the total, absorbtion, and scattering cross section data. Interpolating data of the initial energy distribution of the neutrons. Sampling the initial neutron energies from the energy distribution. Setting the initial position and energies of the neutrons. Setting the position and size of the tank. The initial spectrum is discussed in Initial Energy Spectrum , the method of sampling from a distribution is described in Monte Carlo Sampling , and the interpolation of distributions in Interpolation . After the initializing, the actual simulation of the diffusing neutrons can start. Each neutron's energy and position is updated consecutively which consists of the following steps: Give the neutron a random direction. Check if the neutron is inside the tank, if false end the loop else continue. Get the total cross section corresponding to the current energy of the neutron. Determine the nuclide with which the neutron collides. Check if the the neutron has a thermal energy. Compute the mean free path of the neutron and sample the distance to the next collision. Determine the type of reaction. If it is absorption, end the loop; if it is elastic scattering, proceed. Sample a direction from the angular distribution and compute the associated energy loss fraction. Update the Neutron's position and energy. Repeat steps 2-9 until the neutron either escaped or is absorbed. Each step is discussed in more detail in the following sections: Steps Section 2 Geometry 3-4 Cross Sections 5 Thermal Motion 6 Distance To Next Collision 7 Neutron Interactions 8-9 Handling Scattering Interaction In the simulation, positions and energies of the neutrons are stored. Several properties can be computed and measured from this data post-simulation. The procedure of measuring these properties is described in Measuring Quantities .","title":"1. General Program Flow"},{"location":"theory/#2-neutron-physics","text":"","title":"2. Neutron Physics"},{"location":"theory/#21-initial-energy-spectrum","text":"The neutron source used is a mixture of americium-241 and beryllium-9. The following reactions take place in the source: \\[\\begin{equation} ^{241}_{95}\\text{Am} \\ \\rightarrow \\ ^{237}_{93}\\text{Np} \\ + \\ ^4_2\\text{He}, \\end{equation}\\] \\[\\begin{equation} ^4_2\\text{He} \\ + \\ ^9_4\\text{Be} \\ \\rightarrow \\ ^{12}_6\\text{C} \\ + \\ ^1_0\\text{n}. \\end{equation}\\] The first reaction involves the \\( \\alpha- \\) decay of the americium. The \\( \\alpha \\) particles have a probability of about \\( 10^{-4}\\) to undergo fusion with the berylium, described by the second reaction. This reaction leads to the emmission of neutrons with energies between 3 and 10 MeV. We use the Am-Be energy spectrum (Figure 1) from the ISO 8529-1 standard for sampling the initial energies of the neutrons. Figure 1: ISO neutron spectrum for Am-Be. The neutron spectrum is interpolated to serve as a probability distribution of energies \\( P(\\text{Energy}) \\) . This interpolation and subsequent sampling follow the methodology described in Interpolation and Monte Carlo Sampling respectively. The interpolated initial neutron energy spectrum from the Am-Be source is shown in Figure 2. Figure 2: Interpolated ISO neutron spectrum for Am-Be.","title":"2.1 Initial Energy Spectrum"},{"location":"theory/#22-cross-sections","text":"The cross section indicates the likelihood of a particular interaction occurring between two particles. It is influenced by two main factors: the types of particles involved and their energies. In our scenario, there are two possible combinations of particles in an interaction: a neutron with an H-nucleus and a neutron with an O-nucleus. Unfortunately, it's not possible to calculate the cross section as a function of energy analytically. However, there is an abundance of freely accessible nuclear data available to everyone. In the program, cross section data from ENDF/B is used an interpolated following the procedure outlined in Interpolation . In various reactions, different cross sections are involved. To proceed, we employ the following notations: Notation Description \\(\\sigma_{H, tot}, \\sigma_{O, tot}\\) Total cross section for the specified nuclide. \\(\\sigma_{H, s}, \\sigma_{O, s}\\) Scattering cross section for the specified nuclide. \\(\\sigma_{H, a}, \\sigma_{O, a}\\) Absorption cross section for the specified nuclide. \\(\\Sigma_{H_2O}, \\Sigma_{H}, \\Sigma_{O}\\) Total macroscopic for the specified nuclide or molecule. The theory behind these reactions is described in detail in Neutron Interactions . For each type of cross section and nuclide there are separate datafiles. Total macroscopic cross section for a molecule can be computed as follows: \\[\\begin{equation} \\Sigma = \\sum_i N_i \\sigma_i, \\end{equation}\\] where \\(N_i\\) is the atomic density of atoms of type \\(i\\) : \\[\\begin{equation} N_i = \\frac{\\rho N_a}{M} n_i, \\end{equation}\\] where \\(\\rho\\) is the density of the compound, \\(M\\) the molecular weight, \\(N_a\\) Avogrado's constant, and \\(n_i\\) the number of atoms of type \\(i\\) in the molecule. Thus, the total macrocscopic cross section for \\(H_2O\\) is given by: \\[\\begin{equation} \\Sigma_{H_2O} = \\frac{\\rho_{H_20} N_a}{M_{H_20}} (2 \\sigma_{H, t} + \\sigma_{O, t}). \\end{equation}\\] The cross sections in barns ( \\(10^{-28} m^2\\) ) as a function of neutron energy for the O and H nuclide are shown in Figure 3 and 4. Figure 3: Hydrogen cross sections in barns at temperature T=300K. Figure 4: Oxygen cross sections in barns at temperature T=300K.","title":"2.2 Cross Sections"},{"location":"theory/#23-distance-to-next-collision","text":"The distance to the next collision \\(l\\) follows a distribution function given by: \\[\\begin{equation} p(l)dl=\\Sigma e^{-\\Sigma l}dl, \\end{equation}\\] where \\(\\Sigma\\) is the total macroscopic cross section of an arbitrary material. Integrating both sides to some distance \\(l\\) gives: \\[\\begin{equation} \\int_0^l dl'p(l') = 1 - e^{\\Sigma l}. \\end{equation}\\] As the probability distribution is normalized, we can set the this cummulative distribution to a uniformly distributed random number \\(\\xi\\) on the interval \\( [0, 1) \\) . Isolating \\(l \\) and using that in this case \\(\\Sigma \\equiv \\Sigma_{H_2O} \\) , gives us a formula for sampling the distance to the next collision: \\[\\begin{equation} l = - \\lambda \\ln{\\xi}, \\end{equation}\\] where \\(\\lambda \\) is the mean-free-path which is given by \\[\\begin{equation} \\lambda = 1 / \\Sigma_{H_2O}. \\end{equation}\\] The mean-free-path as a function of neutron energy is shown in Figure 5. Figure 5: Mean-free-path in water as a function of neutron energy.","title":"2.3 Distance to Next Collision"},{"location":"theory/#24-neutron-interactions","text":"To determine the type of reaction involving a nuclide, we initially identify which type of nuclide the neutron interacts with, either \\( H\\) or \\( O\\) . The probability of the neutron interacting with H is determined by: \\[\\begin{equation} P(H) = \\frac{\\Sigma_{H_2}}{\\Sigma_{H_2O}} = \\frac{2\\sigma_{H,tot} }{2\\sigma_{H, tot} + \\sigma_{O, tot}}. \\end{equation}\\] If \\(\\xi < P(H)\\) , where \\(\\xi\\) is another uniformly distributed random number on the interval \\( [0, 1) \\) , the neutron interacts with an \\( H \\) nuclide; otherwise, it interacts with an \\( O \\) nuclide. Since the cross sections depend on the energy of the neutron, \\(P(H) \\) also varies accordingly. The dependence of \\( P(H) \\) on neutron energy is depicted in Figure 6. Figure 6: Probability of H collision as a function of neutron energy. Once the nuclide of interaction is determined, it is necessary to consider the reactions that can take place. Firstly we check absorbtion. The probability for absorbtion is given by: \\[\\begin{equation} P(\\text{absorbtion}) = \\frac{\\sigma_{i,a}}{\\sigma_{i,tot}}, \\end{equation}\\] where \\( \\sigma_{i, tot} \\) and \\( \\sigma_{i, a} \\) are the total and absorbtion cross section of the previously identified nuclide respectively. Again, if \\(\\xi < P(\\text{absorbtion})\\) , then the neutron is absorbed by the nuclide. Absorption results in the complete dissipation of the neutron's energy and we proceed to simulate the next neutron. The absorption probability \\(P(\\text{absorbtion})\\) as a function of neutron energy for H and O are shown in Figure 7 and 8 respectively. Figure 7: Absorbtion probability of H as a function of neutron energy. Figure 8: Absorbtion probability of O as a function of neutron energy. If the criteria mentioned above is not met, we consider a scattering interaction. This interaction leads to a reduction in the neutron's energy, determined by the outgoing angle. This angle is sampled from a distribution specific to the nuclide in question. The process of sampling the angle and computing the neutron's new direction and energy is elaborated upon in the Section Handling Scattering Interaction .","title":"2.4 Neutron Interactions"},{"location":"theory/#25-handling-scattering-interaction","text":"A scattering interaction involving a neutron and nuclide results in an energy loss, which depends on the outgoing angle of the neutron. At lower (thermal) neutron energies, there is notable relative motion between the neutron and the nuclide. The treatment of this scenario is discussed in the Section Thermal Motion . However, at higher energies, it is a reasonable approximation to consider the nuclides as stationary. We can extract the outgoing angles from datasets containing angular distributions sourced from ENDF/B . These distributions, which vary with increasing neutron energies, are defined by Legendre polynomials and are provided in the center-of-mass frame. The representation of these angular distributions using Legendre polynomials is detailed in the ENDF-6 Formats Manual , which we will briefly explain in Angular Distributions . With this angle the new energy and direction of the neutron can be computed as described in Transforming Coordinates .","title":"2.5 Handling Scattering Interaction"},{"location":"theory/#251-angular-distributions","text":"The angular distributions depend on the energy \\(E\\) in the labframe and the cosine of the outgoing angle in the center-of-mass frame \\(\\mu\\) . The distributions are normalized: \\[\\begin{equation} \\int^1_{-1} f(\\mu, E) d\\mu = 1. \\end{equation}\\] We assume that the angular distributions of the scattered neutrons have azimuthal symmetry. This implies that we can uniformly select the azimuthal angle \\(\\phi\\) from the range \\( [0,2\\pi) \\) . The distributions \\( f(\\mu, E) \\) are represented as Legendre polynomials: \\[\\begin{equation} f(\\mu, E) = \\sum_{l=0}^{NL} \\frac{2l+1}{2} a_l(E) P_l(\\mu), \\end{equation}\\] where \\( l\\) is the order of the Legendre polynomial, \\(a_l \\) the \\(l^{th}\\) Legendre polynomial coefficient, and \\( NL \\) the number of Legendre polynomials that represent the distribution. Below in Figure 9 and 10 the angular distributions are plotted for varying neutron energy. Figure 9: Hydrogen scattering angular distribution for varying energy. Figure 10: Oxygen scattering angular distribution for varying energy. EXPLANATION ABOVE FIGURES The neutron energy distributions are discretely spaced for each incoming neutron energy \\(E_i \\) , requiring a selection between the distribution corresponding to the energy immediately above or below the current neutron energy. This is done by defining an interpolation factor: \\[\\begin{equation} f = \\frac{E - E_i}{E_{i+1} - E_i}, \\end{equation}\\] where \\( E \\) is the incoming energy of the neutron. We designate \\(k\\) as the selected distribution index. If \\( \\xi > f \\) , then \\(k=i\\) ; otherwise, \\(k=i+1\\) , where \\( \\xi \\) is a uniform distributed random number on the interval \\( [0, 1) \\) . The cosine of the scattering angle \\(\\mu \\) in the center-of-mass (CM) frame is sampled from the angular distribution corresponding to \\(E_k\\) .","title":"2.5.1 Angular Distributions"},{"location":"theory/#252-transforming-coordinates","text":"From the cosine of the scattering angle in the CM frame \\(\\mu \\) , the secondary velocity of the neutron can be calculated analytically. We start by considering the velocity of the center-of-mass which is given by: \\[\\begin{equation} \\mathbf{v}_{cm} = \\frac{\\mathbf{v}_n + A \\mathbf{v}_t}{1+A} = \\frac{\\mathbf{v}_n}{1+A}, \\end{equation}\\] where A is the mass of the target nuclide, \\( \\mathbf{v}_n \\) the initial velocity of the neutron, and \\( \\mathbf{v}_t \\) is the velocity of the target nuclide. For energies significantly surpassing thermal energy, \\( \\mathbf{v}_t \\) can be considered negligble. The velocity of the neutron can now be transformed to the CM frame: \\[\\begin{equation} \\mathbf{V}_n = \\mathbf{v}_n - \\mathbf{v}_{cm}, \\end{equation}\\] where the capital letter \\( \\mathbf{V} \\) denotes the CM frame. If we express the post-collision direction in the CM frame as \\( \\mathbf{\\Omega}' = (u', v', w') \\) , the components are given by: \\[\\begin{equation} \\begin{aligned} &u' = \\sin{\\theta} \\cos{\\phi} \\\\ &v' = \\sin{\\theta} \\sin{\\phi} \\\\ &w'= \\cos{\\theta} \\end{aligned} \\end{equation}\\] where \\( \\phi \\) is the azimuthal angle and \\( \\theta = \\cos^{-1}(\\mu) \\) . We assume azimuthal symmetry, so \\( \\phi \\) can be sampled from a random uniformly distributed interval \\( [0, 2\\pi) \\) . Finally, transforming back to the lab frame results in the new velocity of the neutron: \\[\\begin{equation} \\mathbf{v}'_n = ||\\mathbf{V}_n|| \\mathbf{\\Omega}' + \\mathbf{v}_{cm}. \\end{equation}\\] The relation between the post- and pre-collision neutron energy in the labframe can be computed as \\[\\begin{equation} E' = \\frac{||\\mathbf{v}'_n||^2}{||\\mathbf{v}_n||^2} E, \\end{equation}\\] and the relation between the old and new position is given by: \\[\\begin{equation} \\mathbf{r}'_n = \\mathbf{r}_n + \\frac{\\mathbf{v}'_n}{||\\mathbf{v}'_n||} l,\\end{equation}\\] where \\( l \\) is obtained following the methodology outlined in Distance to Next Collision .","title":"2.5.2 Transforming Coordinates"},{"location":"theory/#26-thermal-motion","text":"When the energy of the neutron approaches thermal energies, the target nuclide cannot be assumed to be at rest. The target nucleus will have motion associated with its thermal vibration. Thermal motion has an effect on the cross sections and the secondary angular distribution. In The OpenMC Monte Carlo Code a method is described for sampling the velocity of the target nucleus to be used in the elastic scattering kinematic equations described in Handling Scattering Interaction . For the activation process we are mainly interested in the high energy neutrons. For simplicity in the simulation, thermal neutron energies are drawn from a Maxwell-Boltzmann distribution. Furthermore, the resulting direction of a neutron from a scattering reaction is chosen to be random. A neutron is considered thermal when it reaches an energy below the threshold of \\( 10 K_B T \\approx 0.252 \\ eV\\) , where \\( K_B \\) is Boltzmann's constant and \\(T \\) is the temperature of the water. The Maxwell-Boltzmann distribution for \\( T = 293 K \\) is used in the simulation and shown in Figure 11. Figure 11: Maxwell-Boltzmann distribution of energies for T = 293 K. The thermal energy threshold used in the simulation is shown with the dashed line.","title":"2.6 Thermal Motion"},{"location":"theory/#3-geometry","text":"The geometry of the experiment is shown in Figure 12. In the simulation the neutron source is placed at the origin. The water tank of radius \\( R\\) and height \\( h \\) is placed at position \\( \\mathbf{r}_t\\) such that the neutrons diffuse from the correct initial position. Figure 12: Simplified figure of the neutron source in the water tank. The insert containing the target can be moved in the radial direction through slots in the top plate of the water tank. A Neutron at position \\( \\mathbf{r}_n \\) is inside the tank if the following conditions are true: \\[\\begin{equation} \\begin{aligned} & |\\mathbf{r}_n - \\mathbf{r}_t |_{xy} < R \\\\ & |r_{n_z} - r_{t_z} | < h/2, \\\\ \\end{aligned} \\end{equation}\\] where the notation \\( | \\mathbf{r} |_{xy} = \\sqrt{r_x^2 + r_y^2} \\) is used. If these conditions are not met, the neutron is flagged as escaped and the simulation proceeds with simulating the next neutron.","title":"3 Geometry"},{"location":"theory/#4-monte-carlo-sampling","text":"In the initilization the energies of the neutrons are sampled from the distribution shown in Figure 2. The secondary angles of the neutrons in a scattering interaction are sampled from angular distributions on the fly. Some examples of these angular distributions are shown in Figure 10. Finally, when a neutron reaches the thermal energy threshold, its energies are sampled from the Boltzmann distribution shown in Figure 11. The Monte Carlo method used in the simulation is rejection sampling. For simplicity, the proposal distribution is chosen to be a uniform distribution on the interval \\([0, 1) \\) for each of the sampling processes. The following steps are performed to sample a point from a PDF \\(f\\) : Sample y uniformly on the interval \\([0, 1) \\) and \\( x\\) between the bounds of the \\( f \\) . Compute \\( P = f(x) \\) . If \\( y \\leq P \\) stop the process and return \\(x\\) , else go back to step 1. Figure 13 illustrates a large sample obtained from an angular distribution using rejection sampling. This figure is meant to demonstrate the sampling method, as in the simulation, only one secondary angle is sampled per elastic collision. Figure 13: Sample of size N = 10000 obtained from the angular distribution of an elastic O-n collision at E = 5.48e6 eV using rejection sampling.","title":"4 Monte Carlo Sampling"},{"location":"theory/#5-interpolation","text":"","title":"5 Interpolation"},{"location":"theory/#6-measuring-quantities","text":"For neutron activation, we are interested in the flux and the energy spectrum of the neutrons at varying radius in the tank. These quantities can be computed from the positions of the neutrons and the energies of the neutrons at each collisions sight in the tank, which are stored after running the simulation.","title":"6 Measuring Quantities"},{"location":"theory/#61-flux","text":"","title":"6.1 Flux"},{"location":"theory/#62-energy-spectrum","text":"","title":"6.2 Energy Spectrum"},{"location":"user_guide/","text":"User Guide 1. Quick Install Guide NeutroWater requires Python >=3.10. You can install it from PyPI with pip : pip install neutrowater 2. Example Usage In this section an example is given of the usual workflow with NeutroWater. Below, a simulation is set-up and run for specific parameters and analyzed afterwards. First import the diffusing_neutrons module: from neutrowater import diffusing_neutrons as dn Next, set up the simulation with specific parameters: params = dn.Parameters( nNeutrons=10, radius_tank=0.225, height_tank=0.85, position_tank=(0, 0, -0.175) ) neutrons = dn.DiffusingNeutrons(params) Run the simulation for a specified number of collisions: neutrons.diffuse(nCollisions=100000) After the simulation has run, we can analyze the neutrons: from neutrowater.post import measure, plot Let's plot the trajectories: plot.trajectories(neutrons) The measure module can be used to compute several quantities, such as the flux and energy spectrum at a specific distance \\(r = 0.1\\) from the origin: meas = measure.Measurer(neutrons) fluxes = meas.flux(r = 0.1) energies = meas.energy_spectrum(r = 0.1) The full list of measure.Measurer methods, can be found in the API reference .","title":"User Guide"},{"location":"user_guide/#user-guide","text":"","title":"User Guide"},{"location":"user_guide/#1-quick-install-guide","text":"NeutroWater requires Python >=3.10. You can install it from PyPI with pip : pip install neutrowater","title":"1. Quick Install Guide"},{"location":"user_guide/#2-example-usage","text":"In this section an example is given of the usual workflow with NeutroWater. Below, a simulation is set-up and run for specific parameters and analyzed afterwards. First import the diffusing_neutrons module: from neutrowater import diffusing_neutrons as dn Next, set up the simulation with specific parameters: params = dn.Parameters( nNeutrons=10, radius_tank=0.225, height_tank=0.85, position_tank=(0, 0, -0.175) ) neutrons = dn.DiffusingNeutrons(params) Run the simulation for a specified number of collisions: neutrons.diffuse(nCollisions=100000) After the simulation has run, we can analyze the neutrons: from neutrowater.post import measure, plot Let's plot the trajectories: plot.trajectories(neutrons) The measure module can be used to compute several quantities, such as the flux and energy spectrum at a specific distance \\(r = 0.1\\) from the origin: meas = measure.Measurer(neutrons) fluxes = meas.flux(r = 0.1) energies = meas.energy_spectrum(r = 0.1) The full list of measure.Measurer methods, can be found in the API reference .","title":"2. Example Usage"}]}